% http://www.dspguide.com/ch8/4.htm
% https://www.researchgate.net/post/Can_someone_please_provide_me_some_MATLAB_code_for_image_transforms_2D_DFT

% x = input sequence
% X = dft of sequence
x = [1 2 4 1 2 1 2 2 3 2 3];

N = length(x);    % length of the input vector - in this case 11.
for k = 1 : N     % no. of bins
    X(k) = 0;     % empty vector to collect waves 
    for n = 1 : N % there are as many sinusoidal waves as input elements
        % Each wave is added on the previous: X(k) + ...
        % The corresponding element of the input x(n) is multiplied by...
        % exp{-2pii/N...} We divide the circle 2pi into N segments
        % exp{... (n - 1) (k -1)} We start at zero and go to N - 1 to round up the circle:
        X(k) = X(k) + x(n).*exp(-1i.* 2.* pi.*(n - 1).*(k - 1)./ N);
    end
end

% returns X

f = 0:N-1;
subplot(311)
stem(0:N-1, x)
title('Sequence x (in time domain)')
xlabel('time')
ylabel('Amplitude')
grid;

subplot(323)
stem(f,abs(X))
title('Magnitude of Fourier Coeffients using function')
ylabel('|X|')
grid;

subplot(325)
stem(f,angle(X))
title('Angle of Fourier Coeffients using function')
xlabel('Frequency coefficients')
ylabel('<X')
grid;

subplot(324)
stem(f,abs(fft(x)))
title('Magnitude of Fourier Coeffients using fft function')
ylabel('|X|')
grid;

subplot(326)
stem(f,angle(fft(x)))
title('Angle of Fourier Coeffients using fft function')
xlabel('Frequency coefficients')
ylabel('<X')
grid;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% specam.m Compute the spatial frequency spectrum of a square
%           aperture of side L.
clear all;  % Clear memory; print header

%@ Initialize variables
%
NGrid = 100;            % Number of grid points for plots
xMax = 5;              % Values plotted from x= -xMax to x= xMax
yMax = xMax;           % Values plotted from y= -yMax to y= yMax
for i=1:NGrid
  xPlot(i) = -xMax + (i-1)/(NGrid-1)*(2*xMax); % x values to plot
  yPlot(i) = -yMax + (i-1)/(NGrid-1)*(2*yMax); % y values to plot
end

%@ Loop over all grid points and evaluate E(x,y) on grid
for i=1:NGrid
 y = yPlot(i);
 for j=1:NGrid
   x = xPlot(j);   
 
   %@ Compute amplitude of electric field at the grid point
   EPlot(i,j) = sin(pi*x)*sin(pi*y)/(pi*pi*x*y);
  
 end
end

%@ Plot contours of constant electric potential
clf;  figure(gcf);    % Clear figure; bring figure window forward
mesh(xPlot,yPlot,EPlot);  % Plot electric amplitude in contour/mesh plot
xlabel('x, Spatial frequency');  
ylabel('y, Spatial frequency'); 
zlabel('Spectral amplitude');
title('Fourier Transform of a Square Aperature');
hold off;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fxy =[1 2 3 9; 8 5 1 2; 9 8 7 2] % a 3 x 4 matrix
sfxy = size(fxy); % determine size of fxy, which is 3 x 4
m = sfxy(1, 1);  % no. of rows of the matrix, which is 3
n = sfxy(1,2);   % no. of columns of the matrix, which is 4
% double summation over u v using f(x ,y) as element   
for u = 1 :1 :m        % begin with row of dft of fxy; u = 1, 2, 3                   
  for v = 1 :1 :n      % col fxy; v = 1, 2, 3, 4                       
    r(u,v) = 0;        % set init to zero; m 3 x 4 matrix of zeros
    for x = 1 :1 :m    % begin summation over x                                                       
      for y = 1 :1 :n  % begin summation over x                                                        
        axy = fxy(x,y)/m/n;  % element xy       
         % keep in mind index x in formula is from 0 but here it starts from 1 so..(x-1)                                                       
         r(u,v) = r(u,v) + axy * cos(2 * pi *(u *(x - 1) / m + v *(y - 1) / n));                                     
       end                                                   
     end                           
 end 
end 
r

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Plotting ideas:

clear
close all
clc
c = 1560; %m/s
rhoK = 1040; %kg/m^3
rhoS = 1;
K1 = 1/(rhoK*c^2);
K2 = 1;
L = 0.05;%m
f1 = 2e6; %hz
f2 = 2e6; %hz
w = 2*pi*f1;
w0 = 2*pi*f2;
k = w*(K1*rhoK)^0.5;
n = 60;
t = linspace(0,3/f1,n); %s
z = linspace(0,L,n); %m
t1 = t*1e9; %ns
z1 = z *100; %cm
A = (exp(1i*(w0-w)*t)+exp(-1i*(w0+w)*t))/(2*(1+exp(2i*k*L)));
B = (exp(1i*(w0-w)*t)+exp(-1i*(w0+w)*t))/(2*(1+exp(-2i*k*L)));
P = ((A.*exp(1i*w*t))'*exp(1i*k*z))+((B.*exp(1i*w*t))'*exp(-1i*k*z));
% P1 = (exp(1i*w*t))'*((A.*exp(1i*k*z))+(B.*exp(-1i*k*z)));
figure()
surf(t1,z1,real(P));
title('High Frequency Sound Wave')
ylabel('space(cm)')
xlabel('time(ns)')
zlabel('Pressure(Pa)')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% FROM HERE: https://www.youtube.com/watch?v=a7TUIkn3qjY

close all;
clc;
clear all;

%BUILDING UP A FIGURE (A TRIANGLE) WITH 1'S INSIDE AND 0'S OUTSIDE:

figure('Color','w','Units','normalized','OuterPosition',[0 0.05 1 0.95]); % empty canvas
a = 1; % lattice spacing of 1 physical width and height of 1
w  = .9 * a; % triangle sides
Nx = 255; % grid with 255 points across
Ny = Nx; % same height
dx = a / Nx; % cell size
dy = a /Ny; % cell height
xa = [0: Nx - 1] * dx; % horizontal position of each point
ya = [0: Ny - 1] * dy; % vertical position of each point
xa = xa - mean(xa); % centering
ya = ya - mean(ya);
[Y,X] =  meshgrid(ya,xa);

h = w * sqrt(3)/2; % height of an equilateral triangle in relation to sides
ny = round(h / dy); % height in cells of the triangle
ny1 = 1 + floor((Ny - ny)/2); % floor is rounding. this gives the index of the top triangle.
ny2 = ny1 + ny - 1; % bottom of the triangle

UC = zeros(Nx, Ny); % UC = the triangle

  
  for ny = ny1 : ny2
  f = 1 - (ny - ny1 + 1) / (ny2 - ny1 + 1); % index for how many cells wide we are
  nx = round(f * w / dx); % where we are at each altitude level
  nx1 = 1 + floor((Nx - nx)/2);
  nx2 = nx1 + nx + 1;
  UC(nx1: nx2, ny) = 1;
  end
\  



subplot(231); % plotting the triangle
hh = imagesc(xa,ya,UC');
h2 = get(hh,'Parent');
set(h2,'YDir','Normal');
axis equal tight;
colorbar;
title("Unit Cell");
%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%DOING THE FFT THE FAST WAY (BUILT-IN FFT2 2DFT FUNCTION):

A = fftshift(fft2(UC))/(Nx * Ny); % The actual 2D DFT
% ffshift is to bring FFT values from corner to center
% / (Nx * Ny) to preven huge coefficients (scaling)
subplot(232); 
hh = imagesc(xa,ya,real(A'));
h2 = get(hh,'Parent');
set(h2,'YDir','normal');
axis equal tight;
colorbar;
title("FFT2");

% The blue part of the plot is zeroes.
% Zooming to the middle we see the info


% Tuncating the FFT to appreciate the center (where the info is):

NP = 7; %no. points horizontally to grab
NQ = 7; %no. points vertically
p0 = ceil(Nx/2); % middle horizontally
q0 = ceil(Ny/2); % middle vertically
np1 = p0 -  floor(NP/2); % first point horiz
np2 = p0 +  floor(NP/2); % last point horiz
nq1 = q0 -  floor(NQ/2); % first point horiz
nq2 = q0 +  floor(NQ/2);

% A was the fft, now AT will stand with fft truncated:

AT = A(np1:np2, nq1:nq2); % A truncated FFT
pa = [-floor(NP/2): floor(NP/2)]; % new axis
% -3  -2  -1   0   1   2   3
qa = [-floor(NQ/2) : floor(NQ/2)];
% -3  -2  -1   0   1   2   3
subplot(233); 
hh = imagesc(pa,qa,real(AT'));
h2 = get(hh,'Parent');
set(h2,'YDir','Normal');
axis equal tight;
colorbar;
title("TRUNCATED FFT2");

%Time for the inverse fft again with built-in functions (ifft2):

A = zeros(Nx,Ny); %making the fft all zeroes
A(np1:np2, nq1:nq2) = AT; %everything outside tuncated part is zeros


UCT = real(ifft2(ifftshift(A))) * (Nx * Ny); %unit cell from truncated fft
% we undo shifting and scaling
subplot(233); 
hh = imagesc(xa,ya,real(UCT'));
h2 = get(hh,'Parent');
set(h2,'YDir','Normal');
axis equal tight;
colorbar;
title("TRUNCATED UNIT CELL");
% blurry because we used only 7 x 7 NP NQ

% All done with the fast way!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Doing it the slow way:
% Calculate grating vector expansion:
KX = 2 * pi * pa / a; % Seven values
% Remembering that:
% a = 1; % lattice spacing of 1 physical width and height of 1
% and pa comes from:
%AT = A(np1:np2, nq1:nq2); % A truncated FFT
%pa = [-floor(NP/2): floor(NP/2)]; % new axis for the truncated fft (7 values)
% So from side to side we will cover the entire circle.

KY = 2 * pi * qa / a;
% Same for top to bottom

[KY, KX] = meshgrid(KY, KX); % Seven values 49 values

%  Let's start with the whole 256 x 256 Nx, Ny from the beginning

UCT = zeros(Nx, Ny); % new truncated unit cell (unit cell is the triangle)
% UCT is 256 x 256

for nq = 1:NQ %NP = NQ = 7 so it is for 1:7
  for np = 1:NP % for 1:7
    % Calculate planar grating:
    % The actual values of the triangle don't even come into play, only...
    % the position of the pixels in X and Y
    % Each value of the [7 x 7] KX matrix (and KY) scalar multiply all values of X and Y
    
    G = exp(1i * (KX(np, nq) * X + KY(np, nq) * Y));
    
    % KX = 2 * pi * pa / a is [7 x 7] (same as KY)
    % This is the twiddle (?) of this 2DFT
    % pa and qa -3  -2  -1   0   1   2   3 axis TA
    % a is 1 - the physical width
    % [Y,X] =  meshgrid(ya,xa) = 256 x 256 corresponding to point positions.
    % X is [256 x 256] and Y is also [256 x 256].
    % xa = [0: Nx - 1] * dx Horiz pos. of each point
    % ya = Vert pos. of each point 256 = xa
    
    % G is [256 x 256]
    
    %ADDING the Planar Grating to reconstruct cell triangle:
    
    UCT = UCT + AT(np, nq) * G; % we update the 256 x 256 matrix 
    % AT is 7 x 7 matrix of complex numbers  and np nq the indices 1:7
    % Noticing that AT is just the core of A, which is calculated above 
    % with fft2 in-built function!!!!
    % We are reconstructing the triangle ONLY with the center of the DFT!!!
    

    %SHOWING TRUNCATED FFT:
    subplot(234);
    hh = imagesc(pa,qa,real(AT')); % only real part!
    %pa and qa are 7 axis points
    h2 = get(hh, 'Parent');
    set(h2, 'YDir','normal');
    axis equal tight;
    colorbar;
    title('TRUNCATED FFT2');
    hold on;
    x = pa(np) - 0.5 + [0 1 1 0 0]; %creating box around cells
    y = qa(nq) - 0.5 + [0 0 1 1 0];
    line(x,y, 'Color','k','LineWidth',2);
    hold off;
    
    % Show planar grating:
    subplot(235);
    hh = imagesc(xa,ya,real(G')); % only real part!
    % xa and ya are 256-long vectors, and G is 256x256
    h2 = get(hh, 'Parent');
    set(h2, 'YDir','normal');
    axis equal tight;
    colorbar;
    title(['P = ' num2str(pa(np)) ', Q = ' ...
                  num2str(qa(nq))]);
                  
    % Showing reconstructed cell:
    subplot(236);
    hh = imagesc(xa,ya,ifftshift(real(UCT'))); % only real part!
    h2 = get(hh, 'Parent');
    set(h2, 'YDir','normal');
    axis equal tight;
    colorbar;
    title('RECONSTRUCTED UNIT CELL');    
                  
                  
    drawnow;
    % Pay attn to the labels:
    % P is the no. strips along x
    % Q is the no. strips along y
    end
end
\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Work in progress (2 DFT):

% x = input sequence
% X = dft of sequence
x = magic(5);


M = size(x)(1);
N = size(x)(2);
MN = zeros(size(x));    % mat of zeros size of x.
for u = 1 : M     % no. of bins in one direction
    X(u) = 0;     % setting up a counter at zero 
    
    for n = 1 : N % there are as many sinusoidal waves as input elements
        % Each wave is added on the previous: X(k) + ...
        % The corresponding element of the input x(n) is multiplied by...
        % exp{-2pii/N...} We divide the circle 2pi into N segments
        % exp{... (n - 1) (k -1)} We start at zero and go to N - 1 to round up the circle:
        X(k) = X(k) + x(n).*exp(-1i.* 2.* pi.*(n - 1).*(k - 1)./ N);
    end
end

% returns N
