# Mirroring the qr() function of R through Householder QR decomposition:
# Target: http://stackoverflow.com/q/36512466/4089351
# Notation: http://www.netlib.org/lapack/lug/node69.html
# Thanks to: https://youtu.be/d-yPM-bxREs
# Notation: http://math.stackexchange.com/q/1739445/152225
# http://www.netlib.org/lapack/explore-html/da/d82/dormqr_8f.html
# https://stat.ethz.ch/R-manual/R-devel/library/base/html/qraux.html
#######################################################################################################################################

options(scipen=999)
set.seed(13)
(X = matrix(c(rnorm(9)), nrow=3, byrow=F))

A=X
House = function(A){
    Q = diag(nrow(A))
    House.vectors = matrix(0,nrow=nrow(A),ncol=ncol(A))
    for(r in 1:(nrow(A) - 1)){ 
        # We will apply Householder to progressively the columns in A, decreasing 1 element at a time.
        x = A[r:nrow(A), r] 
        # We now get the vector v, starting with first entry = norm-2 of x[i] times 1
        # The sign is to avoid computational issues
        first = (sign(x[1]) * sqrt(sum(x^2))) +  x[1]
        # We get the rest of v, which is x unchanged, since e1 = [1, 0, 0, ..., 0]
        # We go the the last column / row, hence the if statement:
        v = if(length(x) > 1){c(first, x[2:length(x)])}else{v = c(first)}
        # Now we make the first entry unitary:
        u = v/first
        # Tao will be used in the Householder transform, so here it goes:
        t = as.numeric(t(u)%*%u) / 2
        # And the Householder vector are stored as in R qr()$qr function:
        House.vectors[r: nrow(A), r] = u/t
        # The Householder tranformation is:
        I = diag(length(r:nrow(A)))
        H.transf = I - 1/t * (u %*% t(u))
        H_i  = diag(nrow(A))
        H_i[r:nrow(A),r:ncol(A)] = H.transf
        # And we apply the Householder reflection - we left multiply the entire A or Q
        A = H_i %*% A
        Q = H_i %*% Q
    }
    DECOMPOSITION = list("Q"= t(Q), "R"= round(A,7), 
                         "contracted Q as in qr()$qr lower triang"=  
                         ((A*upper.tri(A,diag=T))+(House.vectors*lower.tri(House.vectors,diag=F))), 
                         "Householder.vectors" = House.vectors,
                         "rho"=c(apply(House.vectors[,1:(ncol(House.vectors)-1)], 2, 
                                     function(x) sum(x^2) / 2), -A[nrow(A),ncol(A)]))
    return(DECOMPOSITION)
}

(H = House(X))
qr.Q(qr(X))
qr(X)
